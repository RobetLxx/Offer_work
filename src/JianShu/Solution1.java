package JianShu;import java.util.LinkedList;import java.util.Queue;import java.util.Stack;/** * @author: lingjunhao * create at:  19/5/6  下午6:24 * @description: *//** 单链表*/class Node{    Node next;    int val;    public Node(int x){val=x;}}/*树*/class TreeNode{    TreeNode left;    TreeNode right;    int val;    TreeNode(int x){val = x; }}public class Solution1 {    private static boolean[] visited;    private static int a[][];    public static boolean[] getVisited() {        return visited;    }    public static void setVisited(boolean[] visited) {        Solution1.visited = visited;    }    public static int[][] getA() {        return a;    }    public static void setA(int[][] a) {        Solution1.a = a;    }    public static void DFS(int v, int s[][]){//图的深搜        visited[v]=true;        for (int i = 0; i < a[0].length; i++) {            if (check()&&visited[i]==false){                DFS(i,a);//回溯            }        }    }    public static void DFS(TreeNode head){//树的深搜使用回溯        if (head==null)return;        check();        //满足条件的check()        if (head.left!=null){            DFS(head.left);        }if (head.right!=null){            DFS(head.right);        }    }    public static void BFS(int v){//图的宽搜        Queue<Integer> queue=new LinkedList<>();        Boolean[] visited=new Boolean[a.length*a[0].length];//已被访问节点        visited[v]=true;        queue.add(v);        int []prev=new int[a.length*a[0].length];        int l=0;        prev[l]=0;        while (queue.size()!=0){            int v2=queue.poll();            for (int i = 0; i <a[0].length ; i++) {//从v2点开始往下搜                if (visited[i]==false&&check()){//满足条件的check();                    queue.add(i);                    prev[++l]=i;                }                visited[i]=true;            }        }    }    public static void BFS(TreeNode head){//树的宽搜        if (head==null)return;        Queue<TreeNode> queue=new LinkedList<>();        queue.offer(head);        while (!queue.isEmpty()){            TreeNode m=queue.poll();            //System.out.print(m.val+" ");            //dosomething();            if (m.left!=null){                queue.offer(m.left);            }if (m.right!=null){                queue.offer(m.right);            }            queue.poll();        }    }    public static void BinarySearch(int []a){        int l=0;        int r=a.length-1;        while (l<r){            int mid=l+r>>1;            if (check(a,mid)){                r=mid-1;                //dosomething();            }else {                l=mid+1;                //dosomething();            }        }    }    private static boolean check(){return true;}    private static boolean check(int []a,int mid) {        return true;    }    public static void preOrder(TreeNode head){        if (head!=null){            Stack<TreeNode> stack=new Stack<>();            stack.push(head);            while (!stack.isEmpty()){                head=stack.pop();                System.out.println(head.val+" ");                if (head.right!=null){                    stack.push(head.right);                }                if (head.left!=null){                    stack.push(head.left);                }            }        }    }    public static void inOrder(TreeNode head){        if (head!=null){            Stack<TreeNode> stack=new Stack<>();            while (!stack.isEmpty()||head!=null){                if (head!=null){                    stack.push(head);                    head=head.left;                }else {                    head=stack.pop();                    System.out.println(head.val+" ");                    head=head.right;                }            }        }    }    public static void posOrder(TreeNode head){        if (head!=null){            Stack<TreeNode> stack1=new Stack<>();            Stack<TreeNode> stack2=new Stack<>();            stack1.push(head);            while (!stack1.isEmpty()){                head=stack1.pop();                stack2.push(head);                if (head.left!=null){                    stack1.push(head.left);                }                if (head.right!=null){                    stack1.push(head.right);                }            }            while (!stack2.isEmpty()){                System.out.println(stack2.pop().val+" ");            }        }        System.out.println();    }//    public static void main(String[] args) {//    }    //快排    public static int sort(int a[],int l,int r){        int key=a[l];        while (l<r){            while (l<r&&a[r]>=key){                r--;            }            a[l]=a[r];            while (l<r&&a[l]<=key){                l++;            }            a[r]=a[l];        }        a[r]=key;        return r;    }    public static void QuickSort(int a[],int l,int r){        if (l>r)return;        int mid=sort(a,l,r);        QuickSort(a,l,mid-1);        QuickSort(a,mid+1,r);    }    public static boolean check(int key){        return true;    }    /*    二分查找     */    public static boolean halfSearch(int a[],int l,int r){        while (l<r){            int mid=l+r>>1;            if (check(mid)) r=mid;            else l=mid+1;        }        return false;    }    //递归二分查找一个数,输出这个数在数组中的位置。    public static int halfsearch(int a[],int l,int r,int key){        int mid=l+r>>1;        if (l<r){            if (a[mid]<key){                return halfsearch(a,mid+1,r,key);            }else if (a[mid]>key){                return halfsearch(a,l,mid,key);            }else return mid;        }        return -1;    }    //单链表反转    public static Node reverseNode(Node head){        if (head==null||head.next==null)return head;        Node res=head;        Node x=null;        Stack<Node> p=new Stack<>();        while (res!=null){            p.push(res);            res=res.next;        }        if (!p.isEmpty()){            x=p.pop();        }        while (!p.isEmpty()){            Node sol=p.pop();            x.next=sol;        }        return x;    }    public static void main(String[] args) {        Node s=new Node(1);        Node s1=new Node(2);        Node s2=new Node(3);        Node s3=new Node(4);        s.next=s1;        s1.next=s2;        s2.next=s3;//        while (s!=null) {//            System.out.println(s.val);//            s=s.next;//        }        Node x=reverseNode(s);        while (x!=null){            System.out.println(x.val);            x=x.next;        }    }//    public static void main(String[] args) {//        int a[]={4,2,1,9,6,3,5,8};//        QuickSort(a,0,a.length-1);//        for (int i = 0; i < a.length; i++) {//            System.out.print(a[i]+" ");//        }//        System.out.println();//    }}